[["intro.html", "Archbold Crotalaria avonensis summary 1 Introduction 1.1 Setup", " Archbold Crotalaria avonensis summary 2025-04-10 1 Introduction This supplementary material relates to the Crotalaria avonensis dataset from Archbold Biological Station. The GIS and Data Management program at Archbold Biological Station maintains a comprehensive collection of ecological and environmental data gathered through various research initiatives and ongoing long-term monitoring projects. One key platform for accessing this data is the Archbold Biological Station’ Ecological Data Inventory (EDI), which hosts extensive datasets related to biodiversity, land cover, climate, and ecological patterns. For our model, we utilized 20 years of demographic data on the endangered legume Crotalaria avonensis using an Integrated Population Model (IPM). This dataset has previously been used in the work of Menges et al. 2016. 1.1 Setup We use the following packages: tidyverse, patchwork, skimr, ipmr, binom, bbmle, gridExtra, lme4 "],["data.html", "2 Data 2.1 Data exploration 2.2 Work dataframe/ adjustments", " 2 Data This dataset provides demographic information from a long-term study of Crotalaria avonensis, an endangered small perennial herbaceous legume native to the Lake Wales Ridge in central Florida. The study spans from 1998 to 2017 and monthly during the growing season tracks individual plant survival, size, and reproduction, recorded within permanent quadrats - 25 cm radius circles in stratified random positions within subjectively located belt transects. Additionally, the dataset contains information on fires, herbivory reduction through caging, and other events that might be of effect. Individuals were defined as groups of stems separated by 5 cm or more and marked with plastic toothpicks. Transplant data suggests this species has clonal growth. Code df &lt;- read_csv(file.path(dir_data, &#39;crotalaria_avonensis_data.csv&#39;)) %&gt;% janitor::clean_names() %&gt;% mutate(across(c(5, 6, 11:length(.)), ~ na_if(., 9999))) %&gt;% mutate( plant_id = as.factor(paste(site, quad, plant, sep = &quot;_&quot;)), quad_id = as.factor(paste(site, quad, sep = &quot;_&quot;)), year = as.numeric(substr(date, 1, 4)), month = as.numeric(substr(date, 6, 7)), site = as.factor(site), quad = as.factor(quad), mp = as.factor(mp), plant = as.factor(plant), caged = as.factor(caged), veg = as.factor(veg)) %&gt;% arrange(site, quad, plant, year, month) df_meta &lt;- data.frame(variable = colnames(df)) %&gt;% mutate(definition = c( &#39;study site&#39;, &#39;quadrat number&#39;, &#39;macroplot number&#39;, &#39;plant number (within quad)&#39;, &#39;direction within circular quad&#39;, &#39;distance from quad center&#39;, &#39;was quad caged from 2012 onward&#39;, &#39;vegetation type&#39;, &#39;year quadrat was initiated&#39;, &#39;year-month of observation&#39;, &#39;fire severity Dec. 2014 or Jan. 2015&#39;, &#39;fire severity Aug. 2005&#39;, &#39;fire severity May/June 2009&#39;, &quot;fire severity B&#39;s ridge 2016&quot;, &#39;fire severity Feb. 2017&#39;, &#39;fire severity Oct. 2017&#39;, &#39;survival code for month&#39;, &#39;number of stems&#39;, &#39;number of branch tips&#39;, &#39;number of flowers (corolla showing)&#39;, &#39;number of developing fruits&#39;, &#39;number of mature fruits&#39;, &#39;herbivory code&#39;, &#39;plant identification&#39;, &#39;quadrat identification&#39;, &#39;sample year&#39;, &#39;sample month&#39;)) Expand to skim the raw dataframe Code skimr::skim(df) (#tab:data ab crav skim)Data summary Name df Number of rows 86165 Number of columns 27 _______________________ Column type frequency: character 1 factor 8 numeric 18 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace date 0 1 7 7 0 95 0 Variable type: factor skim_variable n_missing complete_rate ordered n_unique top_counts site 0 1 FALSE 17 1: 22420, 4: 9595, 14: 7315, 13: 6650 quad 0 1 FALSE 95 2: 4180, 1: 4085, 18: 3515, 87: 2660 mp 0 1 FALSE 22 1: 13205, 12: 6555, 17: 6555, 7: 5795 plant 0 1 FALSE 80 1: 8740, 2: 7790, 3: 6935, 4: 6365 caged 0 1 FALSE 2 0: 55290, 1: 30875 veg 0 1 FALSE 3 1: 38475, 3: 25175, 2: 22515 plant_id 0 1 FALSE 906 13_: 190, 1_1: 95, 1_1: 95, 1_1: 95 quad_id 0 1 FALSE 96 1_2: 4180, 1_1: 4085, 4_1: 3515, 13_: 2660 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist bearing 1425 0.98 178.26 103.27 0 90 180 270 360 ▇▇▇▇▇ distance 1330 0.98 16.29 6.85 0 11 17 22 52 ▅▇▆▁▁ quadyr 0 1.00 2000.55 2.82 1998 1998 2001 2002 2009 ▇▆▁▂▁ burn_a 86140 0.00 2.60 0.50 2 2 3 3 3 ▅▁▁▁▇ burn_b 85411 0.01 0.49 0.93 0 0 0 0 3 ▇▁▁▂▁ burn_c 85320 0.01 0.27 0.83 0 0 0 0 4 ▇▁▁▁▁ burn_d 86146 0.00 0.79 0.92 0 0 1 1 3 ▇▅▁▂▁ burn_e 86149 0.00 0.81 0.98 0 0 0 2 2 ▇▁▁▁▅ burn_f 85274 0.01 0.03 0.20 0 0 0 0 2 ▇▁▁▁▁ s 41528 0.52 0.39 0.61 0 0 0 1 6 ▇▁▁▁▁ st 70291 0.18 2.28 2.09 1 1 2 3 33 ▇▁▁▁▁ br 70293 0.18 4.22 5.39 0 1 2 5 85 ▇▁▁▁▁ fl 70283 0.18 0.25 1.30 0 0 0 0 43 ▇▁▁▁▁ dv 70449 0.18 0.04 0.47 0 0 0 0 30 ▇▁▁▁▁ fr 70449 0.18 0.02 0.26 0 0 0 0 15 ▇▁▁▁▁ h 70093 0.19 0.16 0.56 0 0 0 0 6 ▇▁▁▁▁ year 0 1.00 2008.52 5.42 1999 2004 2009 2013 2017 ▆▇▅▇▇ month 0 1.00 4.25 1.79 2 3 4 5 12 ▇▆▁▁▁ 2.1 Data exploration Each year recorded in the dataset includes multiple months of observations per individual. For the purpose of modeling population dynamics, we condensed the data to provide a single observation per individual for size, recruits, survival, flowering, fruiting, and fire exposure for each year. The data were condensed as follows: Size was measured as the number of branch tips, and following the recommendations of Menges et al. (2016), we focused on the maximum size observed in each year. &amp; 3. Recruits and survival were recorded as binary variables, indicating whether the event occurred in a given year. Without recommendation of Menges et al. (2016), we decided to take the mean count of fruits as our estimation of how many fruits were produced by each plant individual per year. Maybe we need to revisit this, as fruits may be more short-lived than expected. If the fruits do not carry over into the next month, maybe the sum of all produced fruits is more appropriate. As for the production of flowers, it seems they to not carry over into the next month. See plant ID 1_1_5, in March 2005 this individual produced 20 flowers, and in April they didn’t find any. At the same time, how is this possible that this individual produced 100 flowers over 20 years, but not a single fruit!? Actually, given that we model flowering with a binomial distribution, it is not the sum of the flowers but just yes or no. The treatment of fire exposure is still undecided as of March 19, 2025. Code df_mean_og &lt;- df %&gt;% filter(s &lt; 6 | is.na(s)) %&gt;% group_by(site, quad, plant, plant_id, year) %&gt;% summarise( survives = if_else(all(is.na(s )), NA_real_, max (s, na.rm = TRUE)), size_t0 = if_else(all(is.na(br)), NA_real_, max (br, na.rm = TRUE)), flower = if_else(all(is.na(fl)), NA_real_, sum (fl, na.rm = TRUE)), fruit = if_else(all(is.na(fr)), NA_real_, mean(fr, na.rm = TRUE)), fire_sev = if_else( all(is.na(c(burn_a, burn_b, burn_c, burn_d, burn_e, burn_f))), NA_real_, mean(c(burn_a, burn_b, burn_c, burn_d, burn_e, burn_f), na.rm = TRUE)), .groups = &quot;drop&quot; ) %&gt;% ungroup() Expand to skim the condenced raw dataframe Code skimr::skim(df_mean_og) Table 2.1: Data summary Name df_mean_og Number of rows 17214 Number of columns 10 _______________________ Column type frequency: factor 4 numeric 6 ________________________ Group variables None Variable type: factor skim_variable n_missing complete_rate ordered n_unique top_counts site 0 1 FALSE 17 1: 4484, 4: 1919, 14: 1463, 13: 1311 quad 0 1 FALSE 95 2: 836, 1: 817, 18: 703, 87: 532 plant 0 1 FALSE 80 1: 1729, 2: 1558, 3: 1387, 4: 1273 plant_id 0 1 FALSE 906 1_1: 19, 1_1: 19, 1_1: 19, 1_1: 19 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist year 0 1.00 2008.00 5.48 1999 2003 2008 2013 2017 ▇▇▆▇▇ survives 7816 0.55 0.53 0.68 0 0 0 1 5 ▇▁▁▁▁ size_t0 12843 0.25 5.48 6.70 1 2 3 7 85 ▇▁▁▁▁ flower 12840 0.25 0.91 3.01 0 0 0 0 71 ▇▁▁▁▁ fruit 12845 0.25 0.02 0.14 0 0 0 0 5 ▇▁▁▁▁ fire_sev 14709 0.15 0.27 0.77 0 0 0 0 4 ▇▁▁▁▁ 2.2 Work dataframe/ adjustments Disclaimer: As of March 2025, we have not been in contact with the corresponding author. During our exploration of the dataset, we found that the survival variable was coded as a factor. In addition to the obvious values indicating survival (1) and non-survival (0), dataset includes values that we interpret as follows: birth (3), birth after fire exposure (5), and missing observations (6). We excluded the missing observations (6) from the dataset entirely. For the survival variable, we re-coded the birth entries (3 and 5), assigning a survival value of 1 if the individual survived and 0 if the individual did not survive. The species is known to exhibit dormancy, and this is reflected in the dataset. The longest dormancy period recorded was 3 years. We included dormancy as a new variable in the dataset. However, it is important to note that for a 3-year period close to the beginning or end of the records, we cannot be certain of an individuals true birth or death. In these cases, the dormancy, survival, and birth variables were marked as NA. Additionally, we included the size of individuals in the subsequent year as a variable. In cases where dormancy was recorded, the size variable was marked as NA. Upon the conclusion of dormancy, the individual’s size was recorded for the following year. For individuals whose true birth could be determined (i.e., those born at least 4 years after the start of the records), we classified them as recruits and included an age variable, which increased through periods of dormancy. Code df_mean &lt;- df_mean_og %&gt;% group_by(site, quad, plant, plant_id) %&gt;% # Handle survival based on previous dormancy status # If the current status is dead or NA # Check if survived in the previous 1, 2, or 3 years # Check if survives in the next 1, 2, or 3 years mutate( survives = if_else( (survives == 0 | is.na(survives)) &amp; (lag(survives, 1) %in% c(1, 3, 5) | lag(survives, 2) %in% c(1, 3, 5) | lag(survives, 3) %in% c(1, 3, 5)) &amp; (lead(survives, 1) %in% c(1, 3, 5) | lead(survives, 2) %in% c(1, 3, 5) | lead(survives, 3) %in% c(1, 3, 5)), 1, survives ), # Set survival to 0 if plant dies after 3 consecutive years of dormancy survives = if_else( survives == 1 &amp; lead(survives, 1) == 0 &amp; lead(survives, 2) == 0 &amp; lead(survives, 3) == 0, 0, survives ) ) %&gt;% # Define dormancy mutate( dormancy = case_when( survives == 1 &amp; is.na(size_t0) ~ 1, size_t0 &gt; 0 ~ 0, TRUE ~ NA_real_ ), # Generate a new column &#39;dormancy_count&#39; that counts consecutive 1s dormancy_count = case_when( dormancy == 1 &amp; lag(dormancy, 1) == 1 &amp; lag(dormancy, 2) == 0 ~ 2, dormancy == 1 &amp; lag(dormancy, 1) == 1 &amp; lag(dormancy, 2) == 1 ~ 3, dormancy == 1 ~ 1, TRUE ~ dormancy) ) %&gt;% # Define recruits mutate( recruit = case_when( (survives == 3 | survives == 5) ~ 1, TRUE ~ NA_real_ ) ) %&gt;% mutate( # Make sure that no survival value exceeds 1 survives = if_else(survives &gt; 1, 1, survives), # Handle missing size_t0 for dead plants by setting NA in survival column survives = if_else(survives == 0 &amp; is.na(size_t0), NA, survives) ) %&gt;% ungroup() %&gt;% arrange(site, quad, plant, year) %&gt;% group_by(site, quad, plant, plant_id) %&gt;% # Set size_t1 based on survival; propagate size_t0 if survives, otherwise set to NA mutate( size_t1 = case_when( survives == 1 ~ lead(size_t0), TRUE ~ NA_real_ ) ) %&gt;% ungroup() %&gt;% # Compute log-transformed sizes and their powers for modeling mutate( logsize_t0 = log(size_t0), logsize_t1 = log(size_t1), logsize_t0_2 = logsize_t0^2, logsize_t0_3 = logsize_t0^3 ) %&gt;% group_by(site, quad, plant, plant_id) %&gt;% mutate(age = NA_real_) %&gt;% # Initialize age as NA for all # Apply for loop to calculate age mutate(age = { # Initialize age vector age_vector &lt;- rep(NA_real_, n()) # Iterate over each row in the group (each site, quad, and plant combination) for (i in 1:n()) { if (!is.na(recruit[i]) &amp;&amp; recruit[i] == 1) { age_vector[i] &lt;- 1 # Set age to 1 for recruits } else if (!is.na(dormancy[i]) &amp;&amp; dormancy[i] &gt;= 0) { # If plant survives, increment the age based on previous value if (i &gt; 1 &amp;&amp; !is.na(age_vector[i - 1])) { age_vector[i] &lt;- age_vector[i - 1] + 1 } } } # Return the computed age vector age_vector }) %&gt;% ungroup() Expand to skim the working dataframe Code skimr::skim(df_mean) Table 2.2: Data summary Name df_mean Number of rows 17214 Number of columns 19 _______________________ Column type frequency: factor 4 numeric 15 ________________________ Group variables None Variable type: factor skim_variable n_missing complete_rate ordered n_unique top_counts site 0 1 FALSE 17 1: 4484, 4: 1919, 14: 1463, 13: 1311 quad 0 1 FALSE 95 2: 836, 1: 817, 18: 703, 87: 532 plant 0 1 FALSE 80 1: 1729, 2: 1558, 3: 1387, 4: 1273 plant_id 0 1 FALSE 906 1_1: 19, 1_1: 19, 1_1: 19, 1_1: 19 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist year 0 1.00 2008.00 5.48 1999 2003.00 2008.00 2013.00 2017.00 ▇▇▆▇▇ survives 13012 0.24 0.89 0.32 0 1.00 1.00 1.00 1.00 ▁▁▁▁▇ size_t0 12843 0.25 5.48 6.70 1 2.00 3.00 7.00 85.00 ▇▁▁▁▁ flower 12840 0.25 0.91 3.01 0 0.00 0.00 0.00 71.00 ▇▁▁▁▁ fruit 12845 0.25 0.02 0.14 0 0.00 0.00 0.00 5.00 ▇▁▁▁▁ fire_sev 14709 0.15 0.27 0.77 0 0.00 0.00 0.00 4.00 ▇▁▁▁▁ dormancy 12699 0.26 0.03 0.18 0 0.00 0.00 0.00 1.00 ▇▁▁▁▁ dormancy_count 12699 0.26 0.04 0.26 0 0.00 0.00 0.00 3.00 ▇▁▁▁▁ recruit 16935 0.02 1.00 0.00 1 1.00 1.00 1.00 1.00 ▁▁▇▁▁ size_t1 13716 0.20 5.96 7.01 1 2.00 4.00 7.00 85.00 ▇▁▁▁▁ logsize_t0 12843 0.25 1.22 0.95 0 0.69 1.10 1.95 4.44 ▇▆▅▁▁ logsize_t1 13716 0.20 1.32 0.94 0 0.69 1.39 1.95 4.44 ▇▇▆▂▁ logsize_t0_2 12843 0.25 2.39 2.84 0 0.48 1.21 3.79 19.74 ▇▂▁▁▁ logsize_t0_3 12843 0.25 5.43 9.07 0 0.33 1.33 7.37 87.69 ▇▁▁▁▁ age 16294 0.05 2.96 2.02 1 1.00 2.00 4.00 12.00 ▇▂▁▁▁ "],["investigation.html", "3 Investigations 3.1 Issue 1. - Size of recruits 3.2 Issue 2 - Size after Dormancy 3.3 Issue 3 - Flagged 3.4 Issue 4 - Fires 3.5 Issue 5 - Spatial relationship", " 3 Investigations We will now investigate several key aspects of the data to maximize its utility, given the constraints. Specifically, we aim to address the following questions: How does the size of recruits develop over time? What is the size trajectory following the exit from dormancy? Is it possible to distinguish between true recruits and individuals exiting dormancy when their first appearance coincides with the beginning of the observation period? Fires Spatial relationships between sites or plots 3.1 Issue 1. - Size of recruits To understand how the plants develop over time, we first examine the size at their first appearance. We can confidently identify this as their first appearance only if there is a record of three consecutive years with no presence prior to that year. Code i1_hist &lt;- ggplot(df_mean %&gt;% filter(recruit == 1), aes(x = size_t0)) + geom_histogram(binwidth = 1, fill = &quot;lightgray&quot;, color = &quot;black&quot;) + theme_minimal() df_mean_r &lt;- df_mean %&gt;% filter(plant_id %in% df_mean$plant_id[df_mean$recruit == 1]) %&gt;% # 1_4_17 has a problem filter(plant_id != &#39;1_4_17&#39;) mod_i1_glm_size_age_quad &lt;- lmer(logsize_t0 ~ age + I(age^2) + (1| plant_id), data = df_mean_r) df_mean_r$pred_glm_size_age_quad &lt;- predict(mod_i1_glm_size_age_quad, newdata = df_mean_r, re.form = NULL) mod_i1_lm_size_age_quad &lt;- lm (logsize_t0 ~ age + I(age^2), data = df_mean_r) df_mean_r$pred_lm_size_age_quad &lt;- predict(mod_i1_lm_size_age_quad, newdata = df_mean_r, re.form = NULL) i1_size_age &lt;- ggplot(df_mean_r, aes(x = age, y = logsize_t0)) + geom_jitter(aes(color = plant_id), width = 0.1, height = 0.1, alpha = 0.6) + geom_line(aes(y = pred_glm_size_age_quad , color = plant_id), alpha = 0.5) + geom_line(aes(y = pred_lm_size_age_quad), alpha = 1, color = &#39;black&#39;, size = 0.8) + theme_minimal() + labs(x = &quot;Age&quot;, y = &quot;Log Size&quot;, title = &quot;Log Size vs Age of Recruits&quot;) + theme(plot.title = element_text(hjust = 0.5)) + scale_x_continuous( limits = c(0, 12), breaks = seq(0, 12, by = 1)) + theme(legend.position = &quot;none&quot;) # Combine the plots grid.arrange(i1_hist, i1_size_age, ncol = 2) 3.2 Issue 2 - Size after Dormancy This plot shows the distribution of size_t1 for dormant individuals. Most certainly, there are very large individuals that go into dormancy Unfortunately we don’t find any clear pattern that sets the dormant individuals apart form recruits. Code i2_hist &lt;- ggplot(df_mean %&gt;% filter(dormancy == 1), aes(x = size_t1)) + geom_histogram(binwidth = 1, fill = &quot;lightgray&quot;, color = &quot;black&quot;) + labs(title = &quot;Histogram of Size After Dormancy&quot;, x = &quot;Size&quot;, y = &quot;Frequency&quot;) + theme_minimal() + annotate(&quot;text&quot;, x = Inf, y = Inf, label = paste(&quot;n:&quot;, nrow(df_mean %&gt;% filter(dormancy == 1) %&gt;% filter(!is.na(size_t1)))), hjust = 2, vjust = 2, size = 4, color = &quot;black&quot;) + xlim(0, 41) + ylim(0, 41) # Create a vector to store the size values before dormancy == 1 size_before_dormancy &lt;- c() # Loop through the rows and capture the size value before dormancy == 1 for(i in 2:nrow(df_mean)) { if(!is.na(df_mean$dormancy[i]) &amp;&amp; df_mean$dormancy[i] == 1) { size_before_dormancy &lt;- c(size_before_dormancy, df_mean$size_t0[i - 1]) } } # Convert to a data frame for ggplot df_size_before_dormancy &lt;- data.frame(size_t0 = size_before_dormancy) # Create ggplot histogram i2_hist_1 &lt;- ggplot(df_size_before_dormancy, aes(x = size_t0)) + geom_histogram(binwidth = 1, fill = &quot;lightgray&quot;, color = &quot;black&quot;) + labs(title = &quot;Histogram of Size Before Dormancy&quot;, x = &quot;Size&quot;, y = &quot;Frequency&quot;) + theme_minimal() + annotate(&quot;text&quot;, x = Inf, y = Inf, label = paste(&quot;n:&quot;, sum(!is.na(size_before_dormancy))), hjust = 2, vjust = 2, size = 4, color = &quot;black&quot;) + xlim(0, 41) + ylim(0, 41) # Combine the plots grid.arrange(i2_hist_1, i2_hist, ncol = 2) Expand to see the mean dataframe of the very large individuals after dormancy Code print(df_mean %&gt;% filter(plant_id == df_mean %&gt;% filter(dormancy == 1, size_t1 &gt; 15) %&gt;% select(plant_id) %&gt;% .[[1]]) %&gt;% select(plant_id, size_t0), n = 100) ## # A tibble: 18 × 2 ## plant_id size_t0 ## &lt;fct&gt; &lt;dbl&gt; ## 1 1_11_9 5 ## 2 1_11_9 17 ## 3 1_11_9 NA ## 4 1_11_9 2 ## 5 1_11_9 1 ## 6 1_11_9 1 ## 7 1_11_9 NA ## 8 1_11_9 NA ## 9 1_11_9 NA ## 10 4_19_1 1 ## 11 4_19_1 5 ## 12 4_19_1 4 ## 13 4_19_1 NA ## 14 4_19_1 40 ## 15 4_19_1 NA ## 16 4_19_1 NA ## 17 4_19_1 NA ## 18 4_19_1 NA Expand to see the full dataframe of the very large individuals after dormancy Code print(df %&gt;% filter(plant_id == df_mean %&gt;% filter(dormancy == 1, size_t1 &gt; 15) %&gt;% select(plant_id) %&gt;% .[[1]]) %&gt;% select(plant_id, br), n = 100) ## # A tibble: 94 × 2 ## plant_id br ## &lt;fct&gt; &lt;dbl&gt; ## 1 1_11_9 NA ## 2 1_11_9 NA ## 3 1_11_9 5 ## 4 1_11_9 NA ## 5 1_11_9 NA ## 6 1_11_9 NA ## 7 1_11_9 3 ## 8 1_11_9 12 ## 9 1_11_9 NA ## 10 1_11_9 NA ## 11 1_11_9 NA ## 12 1_11_9 NA ## 13 1_11_9 NA ## 14 1_11_9 NA ## 15 1_11_9 NA ## 16 1_11_9 NA ## 17 1_11_9 NA ## 18 1_11_9 NA ## 19 1_11_9 NA ## 20 1_11_9 NA ## 21 1_11_9 NA ## 22 1_11_9 NA ## 23 1_11_9 1 ## 24 1_11_9 NA ## 25 1_11_9 1 ## 26 1_11_9 NA ## 27 1_11_9 NA ## 28 1_11_9 1 ## 29 1_11_9 NA ## 30 1_11_9 NA ## 31 1_11_9 NA ## 32 1_11_9 NA ## 33 1_11_9 NA ## 34 1_11_9 NA ## 35 1_11_9 NA ## 36 1_11_9 NA ## 37 1_11_9 NA ## 38 1_11_9 NA ## 39 1_11_9 NA ## 40 1_11_9 NA ## 41 1_11_9 NA ## 42 1_11_9 NA ## 43 1_11_9 NA ## 44 1_11_9 NA ## 45 1_11_9 NA ## 46 1_11_9 NA ## 47 1_11_9 NA ## 48 4_19_1 NA ## 49 4_19_1 NA ## 50 4_19_1 1 ## 51 4_19_1 NA ## 52 4_19_1 1 ## 53 4_19_1 5 ## 54 4_19_1 5 ## 55 4_19_1 5 ## 56 4_19_1 NA ## 57 4_19_1 1 ## 58 4_19_1 NA ## 59 4_19_1 NA ## 60 4_19_1 4 ## 61 4_19_1 1 ## 62 4_19_1 4 ## 63 4_19_1 NA ## 64 4_19_1 NA ## 65 4_19_1 NA ## 66 4_19_1 NA ## 67 4_19_1 NA ## 68 4_19_1 NA ## 69 4_19_1 1 ## 70 4_19_1 3 ## 71 4_19_1 NA ## 72 4_19_1 6 ## 73 4_19_1 NA ## 74 4_19_1 NA ## 75 4_19_1 NA ## 76 4_19_1 NA ## 77 4_19_1 NA ## 78 4_19_1 NA ## 79 4_19_1 NA ## 80 4_19_1 NA ## 81 4_19_1 NA ## 82 4_19_1 NA ## 83 4_19_1 NA ## 84 4_19_1 NA ## 85 4_19_1 NA ## 86 4_19_1 NA ## 87 4_19_1 NA ## 88 4_19_1 NA ## 89 4_19_1 NA ## 90 4_19_1 NA ## 91 4_19_1 NA ## 92 4_19_1 NA ## 93 4_19_1 NA ## 94 4_19_1 NA 3.3 Issue 3 - Flagged To facilitate direct comparison of observations, we create a new data frame that flags entries based on two criteria. First, individuals with missing size_t0 values for the years 1999, 2000, or 2001 are flagged. Second, individuals with non-missing size_t1 values for any of these years (1999, 2000, or 2001) are also flagged. After applying these flags, we assign an age to each individual. Code df_mean_f &lt;- df_mean %&gt;% group_by(site, quad, plant, plant_id) %&gt;% mutate( flag_1 = if_else( any(year == 1999 &amp; is.na(size_t0)) | (any(year %in% c(1999, 2000)) &amp; all(is.na(size_t0[year %in% c(1999, 2000)]))) | (any(year %in% c(1999, 2000, 2001)) &amp; all(is.na(size_t0[year %in% c(1999, 2000, 2001)]))), 1, 0 ), flag_2 = if_else(any(year %in% c(1999, 2000, 2001) &amp; !is.na(size_t1)), 1, 0) ) %&gt;% ungroup() %&gt;% filter(flag_1 == 1 &amp; flag_2 == 1) # Initialize the age column df_mean_f$age &lt;- NA # Loop through each unique combination of site, quad, and plant for (i in 1:nrow(df_mean_f)) { current_site &lt;- df_mean_f$site[i] current_quad &lt;- df_mean_f$quad[i] current_plant &lt;- df_mean_f$plant[i] # Subset the data for the current combination of site, quad, and plant group_data &lt;- df_mean_f %&gt;% filter(site == current_site, quad == current_quad, plant == current_plant) %&gt;% arrange(year) # Ensure the rows are ordered by year # Initialize the current age starting at NA current_age &lt;- 1 # We will start at 1 when the first non-NA size_t0 is found # Loop through the rows within this group for (j in 1:nrow(group_data)) { if (!is.na(group_data$size_t0[j])) { # If the size_t0 is not NA, assign the current age df_mean_f$age[df_mean_f$site == current_site &amp; df_mean_f$quad == current_quad &amp; df_mean_f$plant == current_plant &amp; df_mean_f$year == group_data$year[j]] &lt;- current_age # Increment the age for the next year current_age &lt;- current_age + 1 } else if (j &gt; 1) { # If size_t0 is NA, carry the age from the previous row previous_year_age &lt;- df_mean_f$age[df_mean_f$site == current_site &amp; df_mean_f$quad == current_quad &amp; df_mean_f$plant == current_plant &amp; df_mean_f$year == group_data$year[j - 1]] df_mean_f$age[df_mean_f$site == current_site &amp; df_mean_f$quad == current_quad &amp; df_mean_f$plant == current_plant &amp; df_mean_f$year == group_data$year[j]] &lt;- previous_year_age } } } The following plots display key patterns in the data: 1. Histogram of Size at t0 showing the distribution of size_t0 for plants at age 1, with bins of width 1. 2. Scatter Plot of Log Size at t0 vs Age visualizing the relationship between age and log size. Code i3_hist &lt;- ggplot(df_mean_f %&gt;% filter(age == 1), aes(x = size_t0)) + geom_histogram(binwidth = 1, fill = &quot;lightgray&quot;, color = &quot;black&quot;) + theme_minimal() i3_size_age &lt;- ggplot() + geom_jitter( data = df_mean_f, aes(x = age, y = logsize_t0)) + theme_minimal() # Combine the plots grid.arrange(i3_hist, i3_size_age, ncol = 2) 3.3.1 Modeling Growth of the Flags In this section, we fit four different linear mixed models to examine the relationship between age and log size at time zero (logsize_t0), incorporating random effects to account for variability among individual plant IDs. Linear Model: The first model uses a linear relationship between age and log size, with a random intercept for plant-id. Quadratic Model: The second model introduces a quadratic term for log size to capture potential non-linear effects of age on log size Linear Model with Age: The third model reverses the dependent and independent variables, modeling log size as a function of age, with a random intercept for plant-id. Quadratic Model with Age: The fourth model extends the third model by including a quadratic term for age. Code # Fit the first model: logsize_t0 ~ age + (1 | plant_id) (linear model) mod_flag_linear &lt;- lmer(age ~ logsize_t0 + (1 | plant_id), data = df_mean_f) #summary(mod_flag_linear) # Predict values using the linear model df_mean_f$predicted_linear &lt;- predict(mod_flag_linear, newdata = df_mean_f, re.form = NULL) # Fit the second model: logsize_t0 ~ age + I(age^2) + (1 | plant_id) (quadratic model) mod_flag_quad &lt;- lmer(age ~ logsize_t0 + I(logsize_t0^2) + (1 | plant_id), data = df_mean_f) #summary(mod_flag_quad) # Predict values using the quadratic model df_mean_f$predicted_quad &lt;- predict(mod_flag_quad, newdata = df_mean_f, re.form = NULL) # Fit the third model: logsize_t0 ~ age + (1 | plant_id) (reversed model) mod_flag_logsize_age &lt;- lmer(logsize_t0 ~ age + (1 | plant_id), data = df_mean_f) #summary(mod_flag_logsize_age) # Predict values using the logsize_t0 ~ age model df_mean_f$predicted_logsize_age &lt;- predict(mod_flag_logsize_age, newdata = df_mean_f, re.form = NULL) # Fit the fourth model: logsize_t0 ~ age + I(age^2) + (1 | plant_id) (quadratic term for age) mod_flag_quad_age &lt;- lmer(logsize_t0 ~ age + I(age^2) + (1 | plant_id), data = df_mean_f) #summary(mod_flag_quad_age) # Predict values using the logsize_t0 ~ age + I(age^2) model df_mean_f$predicted_quad_age &lt;- predict(mod_flag_quad_age, newdata = df_mean_f, re.form = NULL) lm_flag_quad_age &lt;- lm(logsize_t0 ~ age + I(age^2), data = df_mean_f) df_mean_f$predicted_lm_quad_age &lt;- predict(lm_flag_quad_age, newdata = df_mean_f, re.form = NULL) The following plots visualize the relationships captured by the second, third, and fourth models Code # Plot the second model (quadratic relationship for logsize_t0 ~ logsize_t0^2) p_i3_mod_1 &lt;- ggplot(df_mean_f, aes(x = logsize_t0, y = age)) + geom_jitter(aes(color = plant_id), width = 0.1, height = 0.1, alpha = 0.6) + geom_line(aes(y = predicted_quad, color = plant_id), alpha = 0.5) + theme_minimal() + labs(title = &quot;Quadratic Model with Random Intercepts: logsize_t0 vs Age&quot;, y = &quot;Age&quot;, x = &quot;Log Size at t0&quot;) + theme(legend.position = &quot;none&quot;) # Plot the third model (logsize_t0 ~ age relationship) p_i3_mod_2 &lt;- ggplot(df_mean_f, aes(x = age, y = logsize_t0)) + geom_jitter(aes(color = plant_id), width = 0.1, height = 0.1, alpha = 0.6) + geom_line(aes(y = predicted_logsize_age, color = plant_id), alpha = 0.5) + theme_minimal() + labs(title = &quot;Log Size Model with Random Intercepts: Age vs Log Size at t0&quot;, y = &quot;Log Size at t0&quot;, x = &quot;Age&quot;) + theme(legend.position = &quot;none&quot;) # Plot the fourth model (logsize_t0 ~ age + I(age^2) relationship) p_i3_mod_3 &lt;- ggplot(df_mean_f, aes(x = age, y = logsize_t0)) + geom_jitter(aes(color = plant_id), width = 0.1, height = 0.1, alpha = 0.6) + geom_line(aes(y = predicted_quad_age , color = plant_id), alpha = 0.5) + geom_line(aes(y = predicted_lm_quad_age), alpha = 1, color = &#39;black&#39;, size = 0.8) + theme_minimal() + labs(title = &quot;Quadratic Model with Random Intercepts: Age vs Log Size at t0\\nand quadratic LM&quot;, y = &quot;Log Size at t0&quot;, x = &quot;Age&quot;) + theme(legend.position = &quot;none&quot;) grid.arrange(p_i3_mod_1, p_i3_mod_2, p_i3_mod_3, ncol = 2) 3.4 Issue 4 - Fires The data from Carter Creek Tract, Lake Wales Ridge Wildlife Environmental Area, 1998-2017, includes information on the severity of six fire outbreaks during this time. In the data we found the severity of ´0´ for some of the individuals. We raise the question of what a severity of ´0´ means? Once again, as of March 2025, we have not been in contact with the corresponding author. Menges et al. (2016) describe how fire affects Avon Park Harebells, emphasizing the plant’s ability to resprout and thrive after fire. They hypothesize that the plant’s long taproot helps them readily resprout post-fire, supported by their observation of high survival and growth after fire and mechanical disturbances (Menges and Kohfeldt 1995). Fire is crucial for maintaining the biodiversity of Florida scrub and sandhill ecosystems, which rely on periodic fires at intervals of 5 to 60 years (Menges 2007, Menges and Gordon 2010). Menges suggests that protected sites, which are managed with fire, have more positive population trends compared to unprotected sites that do not use fire management (Menges 1999). For example, the Rosemary Path population underwent a prescribed burn in 2005, and fire did not negatively affect initial survival. In fact, survival rates were higher in burned quadrats in 2006-2007 (95.6%) compared to control quadrats (71.4%), and continued to be better in the treated areas in the following years. Growth was influenced by fire and mechanical treatments, with the combination of Gyro-Trac and fire producing higher initial growth than fire alone or the control. Fire also helped with recruitment, increasing germination speed, although herbivory had a negative effect. Avon Park Harebells are strong resprouters after fire, herbivory, and mechanical disturbances that remove their aboveground parts. Menges recommends management practices that encourage pollinators, such as prescribed fire. Unfortunately, neither Menges’ publication nor the data webpage provide information on how fire severity was measured, leaving the level 0 severity fire a mystery, for now. 3.5 Issue 5 - Spatial relationship Is there any spatial relationship regarding size, recruits, flowering, fruiting, ect. In the data we have two chategories of sizes, which are site and plot. "],["models.html", "4 Models 4.1 Data preparation 4.2 Models 4.3 Parameter estimates", " 4 Models For this IPM we will model the following processes: Growth Survival (binmial) Recruits (negative binomial) Fruiting (negative binomial) Flowering (binomial) 4.1 Data preparation 4.1.1 Survival Code df_surv &lt;- df_mean %&gt;% filter(!is.na(survives)) %&gt;% filter(size_t0 != 0) %&gt;% select(plant_id, year, size_t0, survives, size_t1, logsize_t0, logsize_t1, logsize_t0_2, logsize_t0_3) Code p_su_1.1 &lt;- ggplot(data = df_surv) + geom_jitter(aes(x = logsize_t0, y = survives), position = position_jitter(width = 0.1, height = 0.3)) + theme_bw() + theme(axis.text = element_text(size = 8), title = element_text(size = 10)) + labs(title = &#39;Survival&#39;, subtitle = v_ggp_suffix, x = expression(&#39;log(size) &#39; [t0]), y = expression(&#39;Survival to time t1&#39;)) + theme(plot.subtitle = element_text(size = 8)) p_su_1.2 &lt;- ggplot( data = plot_binned_prop(df_mean, 10, logsize_t0, survives)) + geom_point(aes(x = logsize_t0, y = survives), alpha = 1, pch = 16, color = &#39;red&#39; ) + geom_errorbar(aes(x = logsize_t0, ymin = lwr, ymax = upr), size = 0.5, width = 0.5) + scale_y_continuous(breaks = c(0.1, 0.5, 0.9)) + ylim(0, 1.01) + theme_bw() + theme(axis.text = element_text(size = 8), title = element_text(size = 10)) + labs(title = &#39;Survival&#39;, subtitle = v_ggp_suffix, x = expression(&#39;log(size)&#39;[t0]), y = expression(&#39;Survival to time t1&#39;)) + theme(plot.subtitle = element_text(size = 8)) grid.arrange(p_su_1.1, p_su_1.2, ncol = 2) 4.1.2 Growth Code df_grow &lt;- df_mean %&gt;% subset(size_t0 != 0) %&gt;% subset(size_t1 != 0) %&gt;% select(plant_id, year, size_t0, size_t1, age, logsize_t0, logsize_t1, logsize_t0_2, logsize_t0_3) Since we have maximum count of branches in a year on an individual as growth, therefore count (integer) data, we find a binned structure of the logsizes. This effect is more pronounced in the on the lower end. Code ggplot( data = df_grow, aes(x = logsize_t0, y = logsize_t1)) + geom_point(alpha = 0.5, pch = 16, size = 0.7, color = &#39;red&#39;) + theme_bw() + theme(axis.text = element_text(size = 8), title = element_text(size = 10)) + labs(title = &#39;Growth&#39;, subtitle = v_ggp_suffix, x = expression(&#39;log(size) &#39; [t0]), y = expression(&#39;log(size) &#39;[t1])) + theme(plot.subtitle = element_text(size = 8)) 4.1.3 Flowering We model flowering in a binomial fashion, thus we reduce the counts of flowers only to if the individual has flowered or not. Code df_flower &lt;- df_mean %&gt;% filter(!is.na(flower)) %&gt;% filter(size_t0 != 0) %&gt;% select(plant_id, year, size_t0, flower, size_t1, logsize_t0, logsize_t1, logsize_t0_2, logsize_t0_3) %&gt;% mutate(flower = if_else(flower &gt; 0, 1, flower)) Code p_fl_1.1 &lt;- ggplot(data = df_flower) + geom_jitter(aes(x = logsize_t0, y = flower), position = position_jitter(width = 0.1, height = 0.3)) + theme_bw() + theme(axis.text = element_text(size = 8), title = element_text(size = 10)) + labs(title = &#39;Flowering&#39;, subtitle = v_ggp_suffix, x = expression(&#39;log(size) &#39; [t0]), y = expression(&#39;Flowering to time t1&#39;)) + theme(plot.subtitle = element_text(size = 8)) p_fl_1.2 &lt;- ggplot( data = plot_binned_prop(df_flower, 10, logsize_t0, flower)) + geom_point(aes(x = logsize_t0, y = flower), alpha = 1, pch = 16, color = &#39;red&#39; ) + geom_errorbar(aes(x = logsize_t0, ymin = lwr, ymax = upr), size = 0.5, width = 0.5) + scale_y_continuous(breaks = c(0.1, 0.5, 0.9)) + ylim(0, 1.01) + theme_bw() + theme(axis.text = element_text(size = 8), title = element_text(size = 10)) + labs(title = &#39;Flowering&#39;, subtitle = v_ggp_suffix, x = expression(&#39;log(size)&#39;[t0]), y = expression(&#39;Flowering to time t1&#39;)) + theme(plot.subtitle = element_text(size = 8)) grid.arrange(p_fl_1.1, p_fl_1.2, ncol = 2) 4.1.4 Fruting Code df_quad &lt;- df_mean %&gt;% group_by (year, site, quad) %&gt;% summarise(tot_p_area = sum(size_t0, na.rm = T)) %&gt;% ungroup df_group &lt;- df_quad %&gt;% group_by (year) %&gt;% summarise(g_cov = mean(tot_p_area)) %&gt;% ungroup df_cover &lt;- left_join(df_quad, df_group) %&gt;% mutate(year = year + 1) %&gt;% mutate(year = as.integer(year)) %&gt;% drop_na() df_fruit &lt;- df_mean %&gt;% group_by (year, site, quad) %&gt;% summarise(nr_quad = sum(fruit, na.rm = T)) %&gt;% ungroup df_fruit &lt;- left_join(df_cover, df_fruit) Code p_fr_1.1 &lt;- ggplot() + geom_histogram(data = df %&gt;% filter(!is.na(fl)), aes(fl)) + theme_bw() + labs(title = &#39;Fruting&#39;, subtitle = v_ggp_suffix, x = expression(&#39;Number of fruits&#39;), y = expression(&#39;Count&#39;)) + theme(plot.subtitle = element_text(size = 8)) p_fr_1.2 &lt;- ggplot( df_fruit, aes(x = tot_p_area, y = nr_quad)) + geom_point(alpha = 0.5, pch = 16, size = 1, color = &#39;red&#39;) + theme_bw() + labs(title = &#39;Fruitment&#39;, subtitle = v_ggp_suffix, x = expression(&#39;Total parent plant area &#39;[t0]), y = expression(&#39;Number of fruits &#39; [t1])) + theme(plot.subtitle = element_text(size = 8)) grid.arrange(p_fr_1.1, p_fr_1.2, ncol = 2) 4.1.5 Recruits Code df_quad &lt;- df_mean %&gt;% group_by (year, site, quad) %&gt;% summarise(tot_p_area = sum(size_t0, na.rm = T)) %&gt;% ungroup df_group &lt;- df_quad %&gt;% group_by (year) %&gt;% summarise(g_cov = mean(tot_p_area)) %&gt;% ungroup df_cover &lt;- left_join(df_quad, df_group) %&gt;% mutate(year = year + 1) %&gt;% mutate(year = as.integer(year)) %&gt;% drop_na() df_recr &lt;- df_mean %&gt;% group_by (year, site, quad) %&gt;% summarise(nr_quad = sum(recruit, na.rm = T)) %&gt;% ungroup df_recr &lt;- left_join(df_cover, df_recr) Code ggplot( df_recr, aes(x = tot_p_area, y = nr_quad)) + geom_point(alpha = 0.5, pch = 16, size = 1, color = &#39;red&#39;) + theme_bw() + labs(title = &#39;Recruitment&#39;, subtitle = v_ggp_suffix, x = expression(&#39;Total parent plant area &#39;[t0]), y = expression(&#39;Number of recruits &#39; [t1])) + theme(plot.subtitle = element_text(size = 8)) 4.2 Models 4.2.1 Survival Code mod_su_0 &lt;- glm(survives ~ 1, data = df_surv, family = &#39;binomial&#39;) # Logistic regression mod_su_1 &lt;- glm(survives ~ logsize_t0, data = df_surv, family = &#39;binomial&#39;) # Quadratic logistic model mod_su_2 &lt;- glm(survives ~ logsize_t0 + logsize_t0_2, data = df_surv, family = &#39;binomial&#39;) # Cubic logistic model mod_su_3 &lt;- glm(survives ~ logsize_t0 + logsize_t0_2 + logsize_t0_3, data = df_surv, family = &#39;binomial&#39;) # Compare models using AIC mods_su &lt;- list(mod_su_0, mod_su_1, mod_su_2, mod_su_3) mods_su_dAIC &lt;- AICtab(mods_su, weights = T, sort = F)$dAIC # Get the sorted indices of dAIC values mods_su_sorted &lt;- order(mods_su_dAIC) # Establish the index of model complexity if (length(v_mod_set_su) == 0) { mod_su_index_bestfit &lt;- mods_su_sorted[1] v_mod_su_index &lt;- mod_su_index_bestfit - 1 } else { mod_su_index_bestfit &lt;- v_mod_set_su +1 v_mod_su_index &lt;- v_mod_set_su } mod_su_bestfit &lt;- mods_su[[mod_su_index_bestfit]] mod_su_ranef &lt;- coef(mod_su_bestfit) # Generate predictions for survival across a range of sizes mod_su_x &lt;- seq( min(df_surv$logsize_t0, na.rm = T), max(df_surv$logsize_t0, na.rm = T), length.out = 100) # Prepare data for survival plot df_surv_pred &lt;- predictor_fun(mod_su_x, mod_su_ranef) %&gt;% # Inverse logit for predictions boot::inv.logit() %&gt;% data.frame(logsize_t0 = mod_su_x, survives = .) Code p_su_2.1 &lt;- ggplot() + geom_jitter(data = df_surv, aes(x = logsize_t0, y = survives), alpha = 0.25, width = 0.08, height = 0.3) + geom_line(data = df_surv_pred, aes(x = logsize_t0, y = survives), color = line_color_pred_fun(mod_su_ranef), lwd = 2) + theme_bw() + labs(title = &#39;Survival prediction&#39;, subtitle = v_ggp_suffix) + theme(plot.subtitle = element_text(size = 8)) p_su_2.2 &lt;- ggplot() + geom_point(data = plot_binned_prop( df_mean, 10, logsize_t0, survives), aes(x = logsize_t0, y = survives) ) + geom_errorbar( data = plot_binned_prop(df_mean, 10, logsize_t0, survives), aes(x = logsize_t0, ymin = lwr, ymax = upr) ) + geom_line(data = df_surv_pred, aes(x = logsize_t0, y = survives), color = &#39;red&#39;, lwd = 2) + theme_bw() + ylim(0, 1) p_su_2.3 &lt;- p_su_2.1 + p_su_2.2 + plot_layout() p_su_2.3 4.2.2 Growth Code mod_gr_0 &lt;- lm(logsize_t1 ~ 1, data = df_grow) # Linear model mod_gr_1 &lt;- lm(logsize_t1 ~ logsize_t0, data = df_grow) # Quadratic model mod_gr_2 &lt;- lm(logsize_t1 ~ logsize_t0 + logsize_t0_2, data = df_grow) # Cubic model mod_gr_3 &lt;- lm(logsize_t1 ~ logsize_t0 + logsize_t0_2 + logsize_t0_3, data = df_grow) mods_gr &lt;- list(mod_gr_0, mod_gr_1, mod_gr_2, mod_gr_3) mods_gr_dAIC &lt;- AICtab(mods_gr, weights = T, sort = F)$dAIC # Get the sorted indices of dAIC values mods_gr_sorted &lt;- order(mods_gr_dAIC) # Establish the index of model complexity if (length(v_mod_set_gr) == 0) { mod_gr_index_bestfit &lt;- mods_gr_sorted[1] v_mod_gr_index &lt;- mod_gr_index_bestfit - 1 } else { mod_gr_index_bestfit &lt;- v_mod_set_gr +1 v_mod_gr_index &lt;- v_mod_set_gr } mod_gr_bestfit &lt;- mods_gr[[mod_gr_index_bestfit]] mod_gr_ranef &lt;- coef(mod_gr_bestfit) # Predict size at time t1 using the mean growth model df_grow$pred &lt;- predict(mod_gr_bestfit, type = &#39;response&#39;) Code p_gr_2.1 &lt;- ggplot( df_grow, aes(x = logsize_t0, y = logsize_t1)) + # Plot observed data geom_point() + geom_function(fun = function(x) predictor_fun(x, mod_gr_ranef), color = line_color_pred_fun(mod_gr_ranef), lwd = 2) + theme_bw() + labs(title = &#39;Growth prediction&#39;, subtitle = v_ggp_suffix) + theme(plot.subtitle = element_text(size = 8)) p_gr_2.2 &lt;- ggplot( df_grow, aes(x = pred, y = logsize_t1)) + geom_point() + geom_abline(aes(intercept = 0, slope = 1), color = &#39;red&#39;, lwd = 2) + theme_bw() grid.arrange(p_gr_2.1, p_gr_2.2, ncol = 2) Code # Fit a model to assess variance in growth # Fitted values from growth model mod_gr_x &lt;- fitted(mod_gr_bestfit) # Squared residuals mod_gr_y &lt;- resid(mod_gr_bestfit)^2 # Non-linear model for variance mod_gr_var &lt;- nls( mod_gr_y ~ a * exp(b * mod_gr_x), start = list(a = 1, b = 0), control = nls.control(maxiter = 1000, tol = 1e-6, warnOnly = TRUE) ) 4.2.3 Flowering Code mod_fl_0 &lt;- glm(flower ~ 1, data = df_flower, family = &#39;binomial&#39;) # Logistic regression mod_fl_1 &lt;- glm(flower ~ logsize_t0, data = df_flower, family = &#39;binomial&#39;) # Quadratic logistic model mod_fl_2 &lt;- glm(flower ~ logsize_t0 + logsize_t0_2, data = df_flower, family = &#39;binomial&#39;) # Cubic logistic model mod_fl_3 &lt;- glm(flower ~ logsize_t0 + logsize_t0_2 + logsize_t0_3, data = df_flower, family = &#39;binomial&#39;) # Compare models using AIC mods_fl &lt;- list(mod_fl_0, mod_fl_1, mod_fl_2, mod_fl_3) mods_fl_dAIC &lt;- AICtab(mods_fl, weights = T, sort = F)$dAIC # Get the sorted indices of dAIC values mods_fl_sorted &lt;- order(mods_fl_dAIC) # Establish the index of model complexity if (length(v_mod_set_fl) == 0) { mod_fl_index_bestfit &lt;- mods_fl_sorted[1] v_mod_fl_index &lt;- mod_fl_index_bestfit - 1 } else { mod_fl_index_bestfit &lt;- v_mod_set_fl +1 v_mod_fl_index &lt;- v_mod_set_fl } mod_fl_bestfit &lt;- mods_fl[[mod_fl_index_bestfit]] mod_fl_ranef &lt;- coef(mod_fl_bestfit) # Generate predictions for survival across a range of sizes mod_fl_x &lt;- seq( min(df_flower$logsize_t0, na.rm = T), max(df_flower$logsize_t0, na.rm = T), length.out = 100) # Prepare data for survival plot df_flow_pred &lt;- predictor_fun(mod_fl_x, mod_fl_ranef) %&gt;% # Inverse logit for predictions boot::inv.logit() %&gt;% data.frame(logsize_t0 = mod_fl_x, flower = .) Code p_fl_2.1 &lt;- ggplot() + geom_jitter(data = df_flower, aes(x = logsize_t0, y = flower), alpha = 0.25, width = 0.08, height = 0.3) + geom_line(data = df_flow_pred, aes(x = logsize_t0, y = flower), color = line_color_pred_fun(mod_fl_ranef), lwd = 2) + theme_bw() + labs(title = &#39;Survival prediction&#39;, subtitle = v_ggp_suffix) + theme(plot.subtitle = element_text(size = 8)) p_fl_2.2 &lt;- ggplot() + geom_point(data = plot_binned_prop( df_flower, 10, logsize_t0, flower), aes(x = logsize_t0, y = flower) ) + geom_errorbar( data = plot_binned_prop(df_flower, 10, logsize_t0, flower), aes(x = logsize_t0, ymin = lwr, ymax = upr) ) + geom_line(data = df_flow_pred, aes(x = logsize_t0, y = flower), color = &#39;red&#39;, lwd = 2) + theme_bw() + ylim(0, 1) p_fl_2.3 &lt;- p_fl_2.1 + p_fl_2.2 + plot_layout() p_fl_2.3 4.2.4 Fruting Code df_fruit_nona_nr_quad &lt;- df_fruit %&gt;% filter(!is.na(nr_quad)) # Fit a negative binomial model mod_fru &lt;- MASS::glm.nb(nr_quad ~ 1, data = df_fruit_nona_nr_quad) # Generate predictions df_fruit_nona_nr_quad &lt;- df_fruit_nona_nr_quad %&gt;% mutate(mod_pred = predict(mod_fru, type = &#39;response&#39;)) # Summarize total number of fruits and predictions df_fruit_sums_m &lt;- df_fruit_nona_nr_quad %&gt;% summarize(nr_quad = sum(nr_quad), mod_pred = sum(mod_pred)) # Count number of adult individuals indiv_m &lt;- df_surv %&gt;% summarize(n_adults = n()) # Calculate reproduction per capita (both observed and predicted) fruit_pc_m &lt;- indiv_m %&gt;% bind_cols(df_fruit_sums_m) %&gt;% mutate(fruit_pc_mean = mod_pred / n_adults) %&gt;% mutate(fruit_pc_obs = nr_quad / n_adults) %&gt;% drop_na fruit_pc_m ## # A tibble: 1 × 5 ## n_adults nr_quad mod_pred fruit_pc_mean fruit_pc_obs ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4057 65.3 65.3 0.0161 0.0161 4.2.5 Recruits Code df_recr_nona_nr_quad &lt;- df_recr %&gt;% filter(!is.na(nr_quad)) # Fit a negative binomial model for recruitment mod_rec &lt;- MASS::glm.nb(nr_quad ~ 1, data = df_recr_nona_nr_quad) # Generate predictions for recruitment df_recr_nona_nr_quad &lt;- df_recr_nona_nr_quad %&gt;% mutate(mod_pred = predict(mod_rec, type = &#39;response&#39;)) # Summarize total number of recruits and predictions df_rec_sums_m &lt;- df_recr_nona_nr_quad %&gt;% summarize(nr_quad = sum(nr_quad), mod_pred = sum(mod_pred)) # Count number of adult individuals indiv_m &lt;- df_surv %&gt;% summarize(n_adults = n()) # Calculate reproduction per capita (both observed and predicted) repr_pc_m &lt;- indiv_m %&gt;% bind_cols(df_rec_sums_m) %&gt;% mutate(repr_pc_mean = mod_pred / n_adults) %&gt;% mutate(repr_pc_obs = nr_quad / n_adults) %&gt;% drop_na repr_pc_m ## # A tibble: 1 × 5 ## n_adults nr_quad mod_pred repr_pc_mean repr_pc_obs ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4057 279 279. 0.0688 0.0688 4.3 Parameter estimates Code # Survival surv_fe &lt;- data.frame(coefficient = names(coef(mod_su_bestfit)), value = coef(mod_su_bestfit)) surv_out &lt;- Reduce(function(...) rbind(...), list(surv_fe)) %&gt;% mutate(coefficient = as.character(coefficient)) %&gt;% mutate(coefficient = replace( coefficient, grepl(&#39;Intercept&#39;, coefficient), &#39;b0&#39;)) # Growth grow_fe &lt;- data.frame(coefficient = names(coef(mod_gr_bestfit)), value = coef(mod_gr_bestfit)) grow_var &lt;- data.frame(coefficient = names(coef(mod_gr_var)), value = coef(mod_gr_var)) grow_out &lt;- Reduce(function(...) rbind(...), list(grow_fe, grow_var)) %&gt;% mutate(coefficient = as.character(coefficient)) %&gt;% mutate(coefficient = replace( coefficient, grepl(&#39;Intercept&#39;, coefficient), &#39;b0&#39;)) # Flower flwr_fe &lt;- data.frame(coefficient = names(coef(mod_fl_bestfit)), value = coef(mod_fl_bestfit)) flwr_out &lt;- Reduce(function(...) rbind(...), list(flwr_fe)) %&gt;% mutate(coefficient = as.character(coefficient)) %&gt;% mutate(coefficient = replace( coefficient, grepl(&#39;Intercept&#39;, coefficient), &#39;b0&#39;)) # Fruiting &amp; Recruitment &amp; Others rec_size &lt;- df_mean %&gt;% subset(recruit == 1) fru_size &lt;- df_mean %&gt;% subset(fruit == 1) others &lt;- data.frame(coefficient = c(&#39;rec_siz&#39;, &#39;rec_sd&#39;, &#39;fru_siz&#39;, &#39;fru_sd&#39;, &#39;max_siz&#39;, &#39;min_siz&#39;, &#39;fecu_b0&#39;, &#39;frui_b0&#39;), value = c(mean(log(rec_size$size_t0), na.rm = T), sd( log(rec_size$size_t0), na.rm = T), mean(log(fru_size$size_t0), na.rm = T), sd( log(fru_size$size_t0), na.rm = T), df_grow$logsize_t0 %&gt;% max, df_grow$logsize_t0 %&gt;% min, repr_pc_m$repr_pc_mean, fruit_pc_m$fruit_pc_mean)) bind_rows(grow_out %&gt;% mutate(estimate = rep(&#39;growth&#39;, nrow(grow_out))), surv_out %&gt;% mutate(estimate = rep(&#39;survival&#39;, nrow(surv_out))), flwr_out %&gt;% mutate(estimate = rep(&#39;flower&#39;, nrow(flwr_out))), others %&gt;% mutate(estimate = c( &#39;recuitment&#39;, &#39;recuitment&#39;, &#39;fruit&#39;, &#39;fruit&#39;, &#39;other&#39;, &#39;other&#39;, &#39;recuitment&#39;, &#39;fruit&#39;))) %&gt;% `rownames&lt;-`(NULL) %&gt;% select(c(3, 1, 2)) ## estimate coefficient value ## 1 growth b0 0.52284560 ## 2 growth logsize_t0 0.07196754 ## 3 growth logsize_t0_2 0.39567123 ## 4 growth logsize_t0_3 -0.05821068 ## 5 growth a 0.42102398 ## 6 growth b -0.05691497 ## 7 survival b0 1.20774223 ## 8 survival logsize_t0 0.63539085 ## 9 survival logsize_t0_2 0.13632833 ## 10 flower b0 -4.92193401 ## 11 flower logsize_t0 2.73409798 ## 12 flower logsize_t0_2 -0.21538280 ## 13 recuitment rec_siz 0.59790365 ## 14 recuitment rec_sd 0.74122900 ## 15 fruit fru_siz 2.52868293 ## 16 fruit fru_sd 0.62708468 ## 17 other max_siz 4.44265126 ## 18 other min_siz 0.00000000 ## 19 recuitment fecu_b0 0.06877003 ## 20 fruit frui_b0 0.01608742 "],["ipm_scratch.html", "5 IPM from Scratch 5.1 !!!-Question-!!! 5.2 Building the IPM", " 5 IPM from Scratch 5.1 !!!-Question-!!! Let me try to put this into words. To begin, here are the direct questions: How do I implement flowering into the kernel? How do I implement fruiting into the kernel? I reviewed the kernel again to better understand its structure. From what I gather, we have three key components that we focus on: The Survival vector is the easiest to explain. It is defined in the 200th dimension (as are the others), with each bin representing a size class. This vector indicates the probability of survival for individuals within each respective size class. The Growth matrix represents the probability or rate of size change between bins. The Fertility matrix is the rate or probability at which individuals in a particular size class contribute to the next size class through recruits. In this case, it essentially functions as a vector, since the probability of contributing to lower size classes is constant across all size classes, while it decreases for larger classes at the same rate. The Transition matrix combines the Growth matrix and the Survival vector in a multiplicative manner and corrects for eviction. Together, these components make up the Kernel, which is the sum of the Transition matrix and the Fertility matrix. Now, regarding how to incorporate the other two processes (flowering and fruiting), I briefly considered that these processes would likely need to alter the fertility component. However, I realized that I would need more information to proceed. While I could have researched how others have approached this (for the extra glory), I believe it is just the best to ask for your input, especially since the models I have developed based on your suggestions regarding distribution only build on what I already knew from the other models and so I am not sure if this is what we are aming for. Thus, could you maybe first go over the models and then let me know how to proceed? Cheers! 5.2 Building the IPM This is the IPM without the flowers or fruits. Code extr_value &lt;- function(x, field){ subset(x, coefficient == field)$value } pars &lt;- Filter(function(x) length(x) &gt; 0, list( prefix = v_script_prefix, species = v_species, surv_b0 = extr_value(surv_out, &#39;b0&#39;), surv_b1 = extr_value(surv_out, &#39;logsize_t0&#39;), surv_b2 = extr_value(surv_out, &#39;logsize_t0_2&#39;), surv_b3 = extr_value(surv_out, &#39;logsize_t0_3&#39;), grow_b0 = extr_value(grow_out, &#39;b0&#39;), grow_b1 = extr_value(grow_out, &#39;logsize_t0&#39;), grow_b2 = extr_value(grow_out, &#39;logsize_t0_2&#39;), grow_b3 = extr_value(grow_out, &#39;logsize_t0_3&#39;), a = extr_value(grow_out, &#39;a&#39;), b = extr_value(grow_out, &#39;b&#39;), flwr_b0 = extr_value(flwr_out, &#39;b0&#39;), flwr_b1 = extr_value(flwr_out, &#39;logsize_t0&#39;), flwr_b2 = extr_value(flwr_out, &#39;logsize_t0_2&#39;), flwr_b3 = extr_value(flwr_out, &#39;logsize_t0_3&#39;), frui_b0 = extr_value(others, &#39;frui_b0&#39;), frui_sz = extr_value(others, &#39;fru_siz&#39;), frui_sd = extr_value(others, &#39;fru_sd&#39;), fecu_b0 = extr_value(others, &#39;fecu_b0&#39;), recr_sz = extr_value(others, &#39;rec_siz&#39;), recr_sd = extr_value(others, &#39;rec_sd&#39;), L = extr_value(others, &#39;min_siz&#39;), U = extr_value(others, &#39;max_siz&#39;), mat_siz = 200, mod_gr_index = v_mod_gr_index, mod_su_index = v_mod_su_index )) # write.csv(pars, row.names = F, paste0( # dir_data, &#39;/&#39;, v_script_prefix, &#39;_&#39;, v_sp_abb, &#39;_pars.csv&#39;)) Code # General # Invert logit inv_logit &lt;- function(x) {exp(x) / (1 + exp(x))} # Survival # x-sized individual to time t1 sx &lt;- function(x, pars, num_pars = v_mod_su_index) { survival_value &lt;- pars$surv_b0 for (i in 1:num_pars) { param_name &lt;- paste0(&#39;surv_b&#39;, i) if (!is.null(pars[[param_name]])) { survival_value &lt;- survival_value + pars[[param_name]] * x^(i) } } return(inv_logit(survival_value)) } # Growth # Standard deviation of growth model grow_sd &lt;- function(x, pars) { pars$a * (exp(pars$b* x)) %&gt;% sqrt } # Growth from size x to size y gxy &lt;- function(x, y, pars, num_pars = v_mod_gr_index) { mean_value &lt;- 0 for (i in 0:num_pars) { param_name &lt;- paste0(&#39;grow_b&#39;, i) if (!is.null(pars[[param_name]])) { mean_value &lt;- mean_value + pars[[param_name]] * x^i } } sd_value &lt;- grow_sd(x, pars) return(dnorm(y, mean = mean_value, sd = sd_value)) } # Function describing the transition kernel pxy &lt;- function(x, y, pars) { return(sx(x, pars) * gxy(x, y, pars)) } # Recruits # Function describing the recruitment fy &lt;- function(y, pars, h){ n_recr &lt;- pars$fecu_b0 recr_y &lt;- dnorm(y, pars$recr_sz, pars$recr_sd) * h recr_y &lt;- recr_y / sum(recr_y) f &lt;- n_recr * recr_y return(f) } # Kernel kernel &lt;- function(pars) { # number of bins over which to integrate n &lt;- pars$mat_siz # lower limit of integration L &lt;- pars$L # upper limit of integration U &lt;- pars$U # bin size h &lt;- (U - L) / n # lower boundaries of bins b &lt;- L + c(0:n) * h # midpoints of bins y &lt;- 0.5 * (b[1:n] + b[2:(n + 1)]) # Survival vector Smat &lt;- c() Smat &lt;- sx(y, pars) # Growth matrix Gmat &lt;- matrix(0, n, n) Gmat[] &lt;- t(outer(y, y, gxy, pars)) * h # Growth/survival transition matrix Tmat &lt;- matrix(0, n, n) # Correct for eviction of offspring for(i in 1:(n / 2)) { Gmat[1,i] &lt;- Gmat[1,i] + 1 - sum(Gmat[,i]) Tmat[,i] &lt;- Gmat[,i] * Smat[i] } # Correct eviction of large adults for(i in (n / 2 + 1):n) { Gmat[n,i] &lt;- Gmat[n,i] + 1 - sum(Gmat[,i]) Tmat[,i] &lt;- Gmat[,i] * Smat[i] } # Fertility matrix Fmat &lt;- matrix(0, n, n) Fmat[] &lt;- matrix(fy(y, pars, h), n, n) # Full Kernel is simply a summation of fertility and transition matrices k_yx &lt;- Tmat + Fmat return(list(k_yx = k_yx, Fmat = Fmat, Tmat = Tmat, Gmat = Gmat, meshpts = y)) } lambda_ipm &lt;- function(i) { return(Re(eigen(kernel(i)$k_yx)$value[1])) } # mean population growth rate lam_mean &lt;- lambda_ipm(pars) lam_mean ## [1] 0.9450798 "],["bugs.html", "6 BUGS", " 6 BUGS Unfortunately we have the following bugs: The survival variable seems to fail for some observations. Expand to see the bug-dataframe Code # 1_4_17 has a problem df_issue &lt;- df_mean[c(932:950, 1397:1406, 1418:1425, 1749:1759, 1768:1778, 2461:2470, 2348:2354, 2902:2907, 3003:3019, 3432:3438, 3906:3912),] print(df_issue[, 4:10], n = 113) ## # A tibble: 113 × 7 ## plant_id year survives size_t0 flower fruit fire_sev ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1_2_8 1999 1 1 0 0 NA ## 2 1_2_8 2000 NA NA NA NA NA ## 3 1_2_8 2001 1 NA NA NA NA ## 4 1_2_8 2002 1 NA NA NA NA ## 5 1_2_8 2003 NA NA NA NA NA ## 6 1_2_8 2004 1 1 0 0 NA ## 7 1_2_8 2005 1 1 0 0 2 ## 8 1_2_8 2006 1 2 0 0 NA ## 9 1_2_8 2007 1 2 0 0 NA ## 10 1_2_8 2008 1 2 0 0 NA ## 11 1_2_8 2009 1 3 0 0 0 ## 12 1_2_8 2010 1 3 0 0 NA ## 13 1_2_8 2011 NA NA NA NA NA ## 14 1_2_8 2012 NA NA NA NA NA ## 15 1_2_8 2013 1 NA NA NA NA ## 16 1_2_8 2014 NA NA NA NA NA ## 17 1_2_8 2015 NA NA NA NA NA ## 18 1_2_8 2016 NA 3 0 0 NA ## 19 1_2_8 2017 NA NA NA NA 0 ## 20 1_2_33 2008 NA NA NA NA NA ## 21 1_2_33 2009 NA NA NA NA 0 ## 22 1_2_33 2010 NA NA NA NA NA ## 23 1_2_33 2011 NA NA NA NA NA ## 24 1_2_33 2012 1 1 0 0 NA ## 25 1_2_33 2013 NA 1 0 0 NA ## 26 1_2_33 2014 NA NA NA NA NA ## 27 1_2_33 2015 NA NA NA NA NA ## 28 1_2_33 2016 NA NA NA NA NA ## 29 1_2_33 2017 NA NA NA NA 0 ## 30 1_2_34 2010 NA NA NA NA NA ## 31 1_2_34 2011 NA NA NA NA NA ## 32 1_2_34 2012 NA NA NA NA NA ## 33 1_2_34 2013 1 2 0 0 NA ## 34 1_2_34 2014 NA 1 0 0 NA ## 35 1_2_34 2015 NA NA NA NA NA ## 36 1_2_34 2016 NA NA NA NA NA ## 37 1_2_34 2017 NA NA NA NA 0 ## 38 1_3_6 1999 0 1 0 0 NA ## 39 1_3_6 2000 NA NA NA NA NA ## 40 1_3_6 2001 NA NA NA NA NA ## 41 1_3_6 2002 NA NA NA NA NA ## 42 1_3_6 2003 NA NA NA NA NA ## 43 1_3_6 2004 NA NA NA NA NA ## 44 1_3_6 2005 NA NA NA NA 2 ## 45 1_3_6 2006 0 2 0 0 NA ## 46 1_3_6 2007 NA NA NA NA NA ## 47 1_3_6 2008 NA NA NA NA NA ## 48 1_3_6 2009 NA NA NA NA 0 ## 49 1_3_7 1999 NA NA NA NA NA ## 50 1_3_7 2000 1 2 0 0 NA ## 51 1_3_7 2001 1 1 0 0 NA ## 52 1_3_7 2002 NA NA NA NA NA ## 53 1_3_7 2003 1 NA NA NA NA ## 54 1_3_7 2004 1 NA NA NA NA ## 55 1_3_7 2005 NA NA NA NA 2 ## 56 1_3_7 2006 0 4 0 0 NA ## 57 1_3_7 2007 NA NA NA NA NA ## 58 1_3_7 2008 NA NA NA NA NA ## 59 1_3_7 2009 NA NA NA NA 0 ## 60 1_5_6 2008 1 30 2 0.4 NA ## 61 1_5_6 2009 1 50 8 0 0 ## 62 1_5_6 2010 1 31 6 0 NA ## 63 1_5_6 2011 1 6 0 0 NA ## 64 1_5_6 2012 1 17 0 0 NA ## 65 1_5_6 2013 NA 5 0 0 NA ## 66 1_5_6 2014 NA NA NA NA NA ## 67 1_5_6 2015 NA NA NA NA NA ## 68 1_5_6 2016 NA NA NA NA NA ## 69 1_5_6 2017 NA NA NA NA 0 ## 70 1_4_17 2009 NA NA NA NA 0 ## 71 1_4_17 2010 NA NA NA NA NA ## 72 1_4_17 2011 NA NA NA NA NA ## 73 1_4_17 2012 1 NA NA NA NA ## 74 1_4_17 2013 NA NA NA NA NA ## 75 1_4_17 2014 NA NA NA NA NA ## 76 1_4_17 2015 NA NA NA NA NA ## 77 1_7_17 2012 NA NA NA NA NA ## 78 1_7_17 2013 NA NA NA NA NA ## 79 1_7_17 2014 NA NA NA NA NA ## 80 1_7_17 2015 1 1 0 0 NA ## 81 1_7_17 2016 NA NA NA NA NA ## 82 1_7_17 2017 NA NA NA NA 0 ## 83 1_8_6 1999 NA NA NA NA NA ## 84 1_8_6 2000 1 2 0 0 NA ## 85 1_8_6 2001 NA NA NA NA NA ## 86 1_8_6 2002 NA NA NA NA NA ## 87 1_8_6 2003 1 NA NA NA NA ## 88 1_8_6 2004 NA NA NA NA NA ## 89 1_8_6 2005 NA NA NA NA 3 ## 90 1_8_6 2006 1 2 0 0 NA ## 91 1_8_6 2007 1 6 0 0 NA ## 92 1_8_6 2008 1 7 0 0 NA ## 93 1_8_6 2009 1 6 0 0 0 ## 94 1_8_6 2010 1 3 0 0 NA ## 95 1_8_6 2011 1 3 0 0 NA ## 96 1_8_6 2012 0 3 0 0 NA ## 97 1_8_6 2013 NA NA NA NA NA ## 98 1_8_6 2014 NA NA NA NA NA ## 99 1_8_6 2015 NA NA NA NA NA ## 100 1_9_20 2010 NA NA NA NA NA ## 101 1_9_20 2011 NA NA NA NA NA ## 102 1_9_20 2012 NA NA NA NA NA ## 103 1_9_20 2013 1 1 0 0 NA ## 104 1_9_20 2014 NA NA NA NA NA ## 105 1_9_20 2015 NA NA NA NA NA ## 106 1_9_20 2016 NA NA NA NA NA ## 107 1_11_15 2009 NA NA NA NA 0 ## 108 1_11_15 2010 NA NA NA NA NA ## 109 1_11_15 2011 NA NA NA NA NA ## 110 1_11_15 2012 1 1 0 0 NA ## 111 1_11_15 2013 NA NA NA NA NA ## 112 1_11_15 2014 NA NA NA NA NA ## 113 1_11_15 2015 NA NA NA NA NA "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
